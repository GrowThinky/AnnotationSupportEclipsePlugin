# eclipse plug-in dev

- Process Backup
    
    ```
    Process: 
    Vogella Plugin Development Tutorials. 
    The type of tutorial you blindly follow, without knowing what you’re really doing, at first. 
    After a while of doing that and looking up some concepts that kept coming up  
    (Target platform, Extension Points etc.) I started feeling like I know my way around the Eclipse IDE and understand how to approach plugin development. 
    
    I also keep a notebook in notion with some flashcards on modules relevant for the default java editor in eclipse. 
    
    I read through some questions about Plugin development and extending the default java editor on stack overflow and also wrote my own question, to get some pointers on where to start looking at the existing code. 
    
    - Found similar plugin to look at their approach. 
    
    What are my questions at given stages? 
    - what is eclipse plugin dev 
    - which extension point do i use? 
    - which class do I Override or replace ?  (A -> class referenced/generated by extension point)
    - how do I modify the small relevant code snippet after I found it? Subclass or copy existing code and make changes. 
    - how do I make eclipse use my modified method -> does it automatically use the class generated from the extension point? 
    - how do I add to preferences for my plugin’s options? 
    - understanding the structure of extension points -> why does adding to foldingStructureProvider not also add the preferences part and how do I add that?  
    - org.eclipse.ui.preferencePages -> add to existing folding preference page or do I need to make new one? -> I THINK I CANT REPLACE WITHOUT EXTENSION POINT
    - what are internal packages? (like jdt.internal.etc)
    - understanding difference between “similar” classes TextViewer and TextEditor -> looking at package names helps differentiate similar sounding classes’ responsibilities. 
    - how explore large code-base effectively: (jump to locations, be aware of inheritance structure, package structure, -> UML map) 
    
    Things I learned: 
    - note dependencies for import statements 
    - find extension point -> look at generated class -> look at interface definition (install() methods ? ) 
    - just copy existing code of class generated by extension point. -> now you can start modifying
    - extension is registered by adding to features (maybe not necessary if run from right click on project) - but in case of folding provider needs to be set from java > editor > folding > choose folding provider 
    - no need to read every method, some can be understood from comments alone (first hand reminder to write good comments) 
    - Understanding the Java Language Elements and its Eclipse-representation as JavaModel very important (how to express this task in written guide?)  IJavaElement
    	- Compilation Unit (java file ) vs class file (.class created by compiler from java file) etc. 
    - understanding Scanner with Tokens etc. 
    
    Getting on track: 
    - I’m not sure if I use 3.x with compatibility layer or without. -> can I use e4 functionality for my extension? (for folding?) 
    - find example / tutorial on how to extend JTD class - like, what’s the starting point? 
    - find way to extend/replace method (confirm with adding print statement to start).
    
    Understanding Code: 
    - computeFoldingStructure (return if IElement parent is not of type ISourceReference (=associated Source Code))					ctx.getScanner.setSource() (Source = Content of Class.java as String) in FoldStrctureComputationContext. 
    					-> find out why ctx keeps getting passed… connection with parser in ctx? -> 1. for settings
    					-> a FoldingStructureProvider containing a FoldStrctureComputationContext ctx is instantiated FOR EACH .java file !!!
    					-> if ctx not yet has first type -> computeHeaderComment
    					-> explains why only one firstType -> headerComment
    					
    - computeFoldingStructure (ElementsArray with for loop) calls method of same name working with single Element) 
    					- if JavaElement element contains other Elements (implements Interface IParent) -> call method recursively on element.getChildren() again. 
    -> This gives us (for example Java File) : 
    // package declaration - 11
    // type (class) - 7
    // method   - 9
    So missing comment -> must work backwards from one of the other elements (probably method)
    (in everything but last Projection is comments)
    
    - computeFoldingStructure -> cases -> checks folding settings and computes folding range for individual JavaElement 
    - if inner type -> check inner type setting and check is not “anonymous enum”.
     - Annotation set collapse to collapseMembers setting. 
    
    - computeProjectionRanges  
    	-> takes SourceReference  = method + direct comment above. 
    	-> the “ignored” comment at top of myClass example IS the header comment !
    	(last Region is what “implements the source reference” (=code?) all preceding Regions is comments) 
    	-> can I add case for Annotations in? (btw where annotations in “implementation”, comment separation. 
    	-> can I highlight projection ranges to understand better ? 
    	- IJavaElment and ISourceReference (casting)
    	- computeHeaderComment()
    - align Region (ez)
    // comments
    - how do we know its a comment?
    - mysterious way to diff between header comment and java doc
    // code 
    - just take the last one (as in comment “last Region is what “implements the source reference””)
    
    ```
    
- Eclipse Overview
    
    ![https://www.oreilly.com/library/view/eclipse-cookbook/0596007108/tagoreillycom20070228oreillyimages136017.png](https://www.oreilly.com/library/view/eclipse-cookbook/0596007108/tagoreillycom20070228oreillyimages136017.png)
    
- Platform Kernel
    
    Everything starts with the **platformkernel**. The platform kernel is written in native code, and its job is to load the rest of Eclipse; the kernel warns you if it
    can’t find a workable Java installation to run the
    rest of the application. The kernel also loads the Eclipse plug-ins.
    
- Workbench Window
    
    The workbench is Eclipse at its most basic.
    The workbench window displays the menus and toolbars you saw in the Eclipse overview Image (the menu and toolbar items that are displayed are put there by the perspective you’re currently viewing).
    
- Workspace Component
    
    The workspace component in Eclipse manages your
    resources, including what you store on disk. Eclipse manages your resources in `projects`, and by default each project is managed by the workspace component in the Eclipse `workspace` directory.
    
- team component
    
    The team component gives you 
    version control for your code, and it
    supports file sharing.
    
- help component
    
    The help component is Eclipse’s documentation system for
    providing help. It’s an extensible help system; plug-ins can provide their own help, in XML-formatted form, to tell the help system how to navigate their documentation.
    
- Plugins
    
    Eclipse is extendible via plug-ins. Plug-ins can set up their own perspectives,
    editors, views, wizards, and more. For example, the JDT is a plug-in
    that adds its functionality to what the workbench already provides.
    
- Plugins vs. Features
    
    → **plugins can be grouped into features which can be packaged as one executable unit called product**
    
    Plugins: Plugins are the smallest deployable and installable software components of Eclipse.
    
    Each plugin can define extension-points which define possibilities for functionality contributions (code and non-code) by other plugins. Non-code functionality contributions can, for example, provide help content.
    
    Features: A feature project is basically a **list of plugins and other features which can be understood as a logical separate unit.**
    
- Product
    
    a product is a stand-alone program built with the Eclipse platform. A product may
     optionally be packaged and delivered as one or more features, which are
     simply groupings of plug-ins that are managed as a single entity by the
     Eclipse update mechanisms.
    
- Dependencies in Manifest vs in Plugin.xml
    
    the `MANIFEST.MF` will contained the "resolved" list of needed plugins **at runtime**
     "At any time, you can click the add dependencies hyperlink to have `PDE`
     analyze your code and generate the correct dependencies in your `MANIFEST.MF`
     file via either the `Require-Bundle`or `Import-Package` headers."  So you shouldn't modify that part directly. The `plugin.xml` can only contain the *direct dependencies* (as opposed to *all* dep. in MANIFEST.ML).
    
- Application Model
    
    **Stored in → Application.e4xmi** 
    
    In Eclipse 4, the workbench is defined in the so called Application Model. This includes windows, views, perspectives, menu contributions, handlers and key bindings. Using the model you define the general design or “skeleton” of your application. Defining a model doesn’t already require that you implement the single components. For example, you can add a view to the model without implementing its contents.
    
    **The cornerstones of the application model are windows, parts and part containers.** Contrary to the eclipse 3.x platform, **e4 has combined views and editors into the concept of Parts**, which represent views inside a window. If you add a part in the model, you can later connect it to your implementation of the selected view.
    
    ![Screenshot 2022-08-03 at 13-30-47 Eclipse_4_Tutorial.pdf.png](eclipse%20plug-in%20dev%20e0662bbfb4de41dcb2a5dfb05eb1d3d3/Screenshot_2022-08-03_at_13-30-47_Eclipse_4_Tutorial.pdf.png)
    
- Workbench
    
    The Workbench **provides the user interface structure for Eclipse**.
    The purpose of the Workbench is to facilitate the seamless integration 
    of tools. These tools contribute to extension points defined by the 
    Workbench. The Workbench is responsible for the presentation and 
    coordination of the user interface.
    
    **→ In Eclipse 4, the workbench is defined in the so called Application Model.**
    
    → views define the parameters that the workbench needs to provide.
    
- Separation between Workbench and Implementation
    
    Eclipse 4 facilitates a clear separation between the definition of a workbench (i.e. application model) and the implementation of concrete parts of it (e.g. views or handler implementations). Implementations use dependency injection to define which parameters they require. This approach leads to minimal interfaces and implementations that are very easy to test and reuse
    
- Model Fragment
    
    A model fragment is nothing more than a small application model. It contains elements, which are supposed to be added to another application model.
    
    **defines elements which need to be added to the root application model**. Fragments can add anything that can be part of the application model, for example handlers, menu items or even windows.
    
- Model Processors
    
    In addition to being able to use fragments, it is also possible to programmatically extend the application model. In e4 this is accomplished using processors. Processors are especially useful if the extension needs to react to conditions within the existing application model, or if the existing application model is to be modified by an extension.
    
- **Dependency Injection**
    
    When required Object is passed when Class is constructed (by the application framework) 
    
    @ Execute
    
    public void ****execute (MyObject **requiredObject**){
    *// Here is the actual handler code*}
    
- **Eclipse Context**
    
    In Eclipse 4 there is the so-­called Eclipse context. This is a kind of **list of objects that are ready for injection**. Technically this context is a map of strings and objects. Without further information, an object is saved under its full class name, for example “org.eclipse.swt.Composite”. Now, when an object of a particular type is requested, the appropriate context will be searched. If it contains an object of the required type, this object is then used to call a constructor or a method, or to fill a field.
    
- **Accessing the IEclipseContext from 3.x API**
    
    The Eclipse IDE uses the `IEclipseContext`data structure to store central information about the IDE. You can access this information also via the Eclipse 3.x API.
    
    From a View: 
    
    ```
    // get the context of a part
    IEclipseContext partContext = getViewSite().getService(IEclipseContext.class);
    
    // or access directly a value in the context based on its key
    EModelService service =  getViewSite().getService(EModelService.class);
    ```
    
    From a Handler: 
    
    ```
    // the following example assumes you are in a handler
    
    // get context from active window
    IEclipseContext windowCtx =
        HandlerUtil.getActiveWorkbenchWindow(event).getService(IEclipseContext.class);
    
    // get context from active part
    IEclipseContext ctx =
        HandlerUtil.getActivePart(event).getSite().getService(IEclipseContext.class);
    ```
    
- Parts and Part Containers
    
    Part → BuildingBlock of UI Workbench 
    
    As parts cannot exist on their own, they are always contained in PartContainers. Those PartContainers create an application layout. Besides windows, there are two elements which can contain Parts: PartSashes and PartStacks
    
- Parts and Views
    
    When you start the application, Eclipse 4 will create a part within the workbench and the linked view implementation will be initialized. That means, the constructor of the view implementation will be called. Parameters, which are required by the view, will be taken from the current context and will be injected into the view.
    
- Model Spy
    
    Eclipse allows you to define the workbench using the application model even without providing implementations. However, this is sometimes hard to work with, because empty Parts are often hard to identify. To resolve this, there is a special version of the Model Editor called Model Spy. It allows you to access the application model of a running application, modify it and highlight selected components.
    
    Live Editing
    
    In the running application you can start the live editor via ALT+SHIFT+F9. This editor works exactly like the editor in your IDE, however, it directly accesses the application model of the running application. If you, for instance, open the TrimmedWindow in the editor and change its size or position, the changes are directly applied in the running application.
    
- Programmatic Access to the Application Model
    
    @Execute
    
    public void execute(MApplication application) {
    
        MWindow mWindow = MBasicFactory.INSTANCE.createTrimmedWindow();
    
        mWindow.setHeight(200);
    
        mWindow.setWidth(400);
    
        mWindow.getChildren().add(MBasicFactory.INSTANCE.createPart());
    
        application.getChildren().add(mWindow);
    
    }
    
- Handlers
    
    **Handlers are the components, which define some specific behavior to be triggered.**
    
    Parallel to how UI components work in Eclipse 4, handlers don’t have to implement a given interface. Instead, they define the required parameters. Using a "Direct Tool Item” is the fastest way to integrate a handler with an item in the toolbar. However, for more flexibility and better reuse we recommend using commands and handlers.
    
    **3 Components in Application.e4xmi→  Handler, Command, Handled Tool Item** 
    
- Target Platform
    
    Set of locations where to find plug-ins to be used by java classpath, javac claspath. 
    
    The target platform **specifies the set of bundles used to compile and build against within the Eclipse PDE (plugin development environment)**. The default target platform is Eclipse itself, but the target platform can be set to any desired set of bundles.
    
- OSGi
    
    Eclipse is an Application running on implementation of OSGi called Equinox.
    
- Dependencies as Package vs Plugin
- Java Model
    
    [https://wiki.eclipse.org/FAQ_What_is_the_Java_model%3F](https://wiki.eclipse.org/FAQ_What_is_the_Java_model%3F)
    
- Interface JavaFoldingStructureProvider  
    
    ### org.eclipse.jdt.ui.text.folding.IJavaFoldingStructureProvider
    
    Contributors to the `org.eclipse.jdt.ui.foldingStructureProvider` extension point must specify an implementation of this interface which will create and maintain `org.eclipse.jface.text.source.projection.ProjectionAnnotation` objects that define folded regions in the `org.eclipse.jface.text.source.projection.ProjectionViewer`.
    
    Clients may implement this interface.
    
    In order to provide backward compatibility for clients of `IJavaFoldingStructureProvider`, extension interfaces are used to provide a means of evolution. The following extension interfaces exist:
    
    - `org.eclipse.jdt.ui.text.folding.IJavaFoldingStructureProviderExtension` since version 3.2 introducing the following functions:
        - collapsing of comments and members
        - expanding and collapsing of certain java elements
- ProjectionViewer
    
    A projection source viewer is a source viewer which supports multiple visible regions which can dynamically be changed.
    
    The centerpiece of this package is the ProjectionViewer class, which you must use in your plug-in instead of the usual TextViewer class, to implement folding. A ProjectionViewer internally uses a ProjectionDocumentManager to manage the display of Projection Documents, so we don't have to worry about that. It implements the ITextViewerExtension5 interface which is a central part of the UI dependent infrastructure.
    
- Annotation vs. Position
    
    Annotaton → ProjectionViewer   ???
    
    Position → Editor  ???
    
- Scanner vs. Parser
    
    A Scanner simply turns an input String (say a file) into a list of tokens. These tokens represent things like identifiers, parentheses, operators etc.
    
    A parser converts this list of tokens into a Tree-like object to represent how the tokens fit together to form a cohesive whole (sometimes referred to as a sentence).
    

Working with Java Elements:

- Product Configuration File
    
    → when hosting a feature in a product (= plugin project with a product config file)
    
    → includes: version number, contained features etc. 
    
- Common Navigator
    
    The common navigator is used by the Project Explorer view in Eclipse and is used to show the graphics and labels for the packages, classes, and their methods and fields.
    
- Java Model
    
    The Java model is declared in package org.eclipse.jdt.core, which consists of 55 types providing access to anything you would ever need to analyze and manipulate your Java programs.
    
    ISourceReference → consists of:
    
    IClassFile, ICompilationUnit, IPackageDeclaration, IImportDeclaration, IImportContainer, IType, IField, IMethod, IInitializer, ITypeParameter, ILocalVariable, and IAnnotation.
    
    IJavaElement       → Any Java Element (getElementName(), 
    
    IParent                  → Java Element that contains other Elements 
                                  → getChildren()
    
    ICompilationUnit  → Represents an entire Java Compilation Unit ( = Class.java file)
    
- Inner Types / Classes
    
    Java inner class or nested class is **a class that is declared inside the class or interface**.
    
- Java Class file
    
    A Java class file is a file (with the .class filename extension) containing Java bytecode that can be executed on the Java Virtual Machine (JVM). A Java class file is usually produced by a Java compiler from Java programming language source files (.java files)
    
- Header Comment
    - The top of any program file.
        
        This is called the **"Header Comment"**.  It should include
        all the defining information about who wrote the code, and why, and
        when, and what it should do. 
        
- 

Preferences: 

- Preferences Starting Points
    1. IPreferncesStore
        
         getPreferenceStore() - Returns the preference store for this UI plug-in.
        
    2. `org.eclipse.ui.preferencePages`extension point.
    
- IPreferenceConfigurationBlock
- AbstractConfigurationBlockPreferencePage
- Is not API - access rules problem - ask about this
- Preference Storage Location
    1. for each installation (but this may vary for multi-user installations), in files stored in:
            `<eclipse_home>/eclipse/configuration/.settings/`
        
        There is typically one file per plugin, with a prefs extension. Note that very few plug-ins use installation-wide preferences.
        
    2. Preferences are stored in the **workspace** of your application in the ***.metadata/.plugins/org.eclipse.core.runtime/.settings/*** directory.
    The files are called *<nodePath>.prefs* file.
        
        The *<nodePath>* is, by default, the Bundle-SymbolicName of the plug-in.
        It also also be specified via the preference API.
        The workspace is by default the  directory in which the application starts.
        

String Editing: 

- String Editing Starting Points
    
    [https://www.eclipse.org/articles/using-perspectives/PerspectiveArticle.html](https://www.eclipse.org/articles/using-perspectives/PerspectiveArticle.html)
    
    - IWorkbenchWindow → “Use `IWorkbenchWindow.getPages()`
     to get an array of `IWorkbenchPage`containing all the pages and look through the pages for the one containing the editor you want”
    - Work with Document or TextEditor, TextViewer ???
        - only representation inside IDE - not concerned with document.
    - ProjectionViewer (used instead of TextViewer
    
- Workbench Elements
    
    ![https://www.eclipse.org/articles/using-perspectives/workbench_decomposed.jpg](https://www.eclipse.org/articles/using-perspectives/workbench_decomposed.jpg)
    
- get Eclipse’s UI Interface
    
    The root of the user interface is accessed by invoking PlatformUI.getWorkbench( ).  This returns an object of type IWorkbench. A workbench has one or more windows of type IWorkbenchWindow.
    
- “activePage” in Workbench
    
    is all the things you can see on an Eclipse window, there are multiple pages if you have used several perspectives. Normally you use SWT controls in the page and there will be an active page. Or if a dialog is displayed you schedule work to run after the dialog closes and the page is active again
    

![RelevantClasses.png](eclipse%20plug-in%20dev%20e0662bbfb4de41dcb2a5dfb05eb1d3d3/RelevantClasses.png)

- Document
    
    Underlying text data - separate from displaying and editing. 
    
    Master vs. Projection Document: 
    The contents of a projection document are a subset of the contents of the Master Document. In other words, the content of a projection document consists of portions of the Master Document. When you collapse the text in the editor you see the contents of a projection document containing only the expanded sections.
    
- AnnotationModel
    
    The model maintains a set of annotations for a given document and notifies registered annotation model listeners about annotation model changes.
    
- TextViewer
    - A text viewer connects a text widget with an `IDocument`and provides several text editing functions.
    - Does not Support TextFolding.
    - setVisibleRegion() → probably not useful?
- ProjectionViewer
    
    A projection viewer is a source viewer which supports multiple visible regions which can dynamically be changed.
    
    - Implements ITextViewerExtension5 Interface
        
        →  Coordinates/Ranges of:
        
        widged (in textViewer) vs. model (in underlying Document)
        
        exposed / unexposed modelRange in Document (depending on folding status) 
        
        ProjectionListener: 
        
        listeners are informed when the projection mode of the viewer gets enabled and when it gets disabled. 
        
        → i think that’s just when checkbox for folding is set. 
        
- TextEditor
    
    TextEditor (=standard Text Editor) -> extends AbstractDecoratedTextEditor
    **setDocumentProvider(EditorInput input) 
    ->** method in AbstractDecoratedTextEditor - takes input !!!
    
    **Part of Eclipse Workbench UI !!!**
    
    The editor works on the document and forwards all input element related calls, such as “save” to the document provider.
    
- DocumentProvider
    
    Creates IDocument object from EditorInput (in createDocument()-method of AbstractDocumentProvider) in AbstractDocumentProvider’s ElementInfo.
    
    - A document provider maps between domain elements and documents.
    
    Responsibilities:
    
    - create an annotation model of a domain model element
    - create and manage a textual representation, i.e., a document, of a domain
    model element.
    - …
    
- EditorInput
    
    
- JavaEditor
- Access TextEditor
    
    ```java
    TextEditor editor = (TextEditor) PlatformUI.getWorkbench().getActiveWorkbenchWindow()
        .getActivePage().getActiveEditor();
    ```
    
    1. You need to make sure that the active editor really is a `TextEditor`, so you are going to want to do an instanceof test
    2. Sometimes various parts of the long phrase above can be null (eg-
    during startup or shutdown). I tend to just wrap the expression in a
    try-catch(NPE) block and assume that if an NPE is thrown, then the
    editor is not available.
- Select Text in Editor
    
    `editor.getSourceViewer().setSelectedRange(offset, length);`
    
- Slave Documents
    
    Slave documents are documents whose contents is defined in terms of a master document. Thus, slave documents usually reflect a projection of the master document. Slave documents are causally connected to the master document. This means, changes of the master document have immediate effect on the slave document and vice versa.
    
- SlaveDocManager
    
    A slave document manager creates slave documents for given master documents, manages the life cycle of the slave documents, and keeps track of the information flow between master and slave documents. The slave document manager defines the construction rules of the slave documents in terms of the master document.
    
- Child and Parent Documents

- Annotation
    
    An Annotation is a piece of information attached to a certain region of a text document. New kinds of annotations may be defined using this extension point. Annotations are attached to documents via their annotation model and may be displayed in text editors and views.
    
- ProjectionAnnotation
    
     Projection is subclass of Annotation. 
    
- MarkerAnnotation
    
    MarkerAnnotation is underlined stuff for example ?
    
- JavaProjectionAnnotation
    
    Inner Class in DefaultFoldingStructureProvider 
    
    - contains JavaElement type and boolean isComment
    - Tuple Class Pairs JavaProjectionAnnotation with Position

- Folding: happens by ProjectionViewer “excluding” certain lines.
- make changes where?
    - ProjectionViewer
    - TextEditor (manipulate editorInput in editor’s init() )
    - * Partial Line ProjectionViewer modification

- **org.eclipse.jface.text.source**
    
    Provides a framework for connecting document regions
    with annotations and for displaying those annotations in combination with
    an ITextViewer.
    
- IVerticalRuler
    
    This interface defines a visual component which may serve
     text viewers as a line oriented annotation presentation 
     area. This interfaces comprises three contracts:
    
    - The vertical ruler retrieves the annotations it presents from an annotation model.
    - The ruler is a visual component which must be integrated in a hierarchy of SWT controls.
    - The ruler provides interested clients with mapping and	interaction information. This covers the mapping between coordinates of the ruler's control and line numbers based	on the connected text viewer's document (`IVerticalRulerInfo`).
- ProjectionDocument
    
    A `ProjectionDocument`represents a projection of its master
     document. The contents of a projection document is a sequence of fragments of
     the master document, i.e. the projection document can be thought as being
     constructed from the master document by not copying the whole master document
     but omitting several ranges of the master document.
    
- Position
    
    Positions describe text ranges of a document and are adapted to changes applied to that document. The text range is specified by an offset and a length. Positions can be marked as deleted. Deleted positions are considered to no longer represent a valid text range in the managing document.
    
- `ITextViewerExtension5`: Widget vs. Model Coordinates
    
    A widget coordinate corresponds
      to a position on the text viewer while a model coordinate corresponds to a position
      on the document. A widget range always has a corresponding model range which
      maps to the viewer’s document, while on the other hand a model range can be
      either ‘exposed’ or ‘unexposed’. An exposed model range is visible on the viewer
      and can thus be mapped to a widget range. Thus when you expand the text in the
      viewer, that model range is ‘exposed’ and vice versa. `ITextViewerExtension5`
     contains methods to do the conversion from widget to model coordinates and vice
      versa, and to expose model ranges.
    
- `ProjectionSupport`
    
    This class controls the display and configuration of all the UI elements related
      to folding, for example, the painting of those elipsis icons when
      you collapse a region, and the vertical column that contains the triangle icons
      to expand/collapse text. A `ProjectionSupport`instance needs to be installed on a viewer.
    
- Summarizable Annotation Types
    
    `ProjectionSupport`allows you to specify *summarizable annotation types*. Basically, these are the annotations that will appear in the vertical column on the left
      when you fold the text that contains them. For example, JDT specifies the ‘error’
      and ‘warning’ annotation types as summarizable, so that when you fold the text
      that contains a warning or an error, its icon appears on the vertical column
      besides the folding arrow, as shown below.
    
- SetHoverControlCreator
    
    `setHoverControlCreator()`method allows you to set up a hover control to display the collapsed text in a tooltip style box when the use moves the cursor over the arrow
    
- **Projection Annotations**
    
    To enable folding, we have to specify which regions of the text are collapsible.
    We do this by calling `addAnnotation()`adding `ProjectionAnnotations`
     to the ProjectionViewer's`ProjectionAnnotationMode`. The position allows the annotation to be attached to certain text in the editor.
    
    The methods of ProjectionAnnotationModel are pretty self-explanatory:
    
    ```
    class ProjectionAnnotationModel{
    
     public void collapse(Annotation annotation)
     public void expand(Annotation annotation)
     public boolean expandAll(int offset,int length)
    
     public void toggleExpansionState(Annotation annotation)
    
     public void modifyAnnotations(Annotation[] deletions,Map additions,
                                  Annotation[] modifications)
    }
    
    ```
    
- **Class  VerticalRuler**
    
    A vertical ruler which is connected to a text viewer. Single column standard 
     implementation of `IVerticalRuler`
    
- Class Annotation
    
    Abstract graphical annotation used in a vertical ruler. Annotations are considered being located at layers. The vertical ruler paints annotations starting with layer 0 upwards. Thus an annotation of layer 5 will be drawn on top of all co-located annotations at the layers 4 - 0. Subclasses must provide the annotations paint method.
    
- Painting Annotation GUI Elements
    
    ProjectionAnnotation has a method which actually paints those triangles you see
      on the left.
    
    `public void paint(GC gc, Canvas canvas,
      Rectangle rectangle)`
    
    You can override this method in your plug-in if you want to draw something other
      than an triangle on the left side, for example a plus/minus sign.
    
    There is one more method you should know about:
    
    `public void setRangeIndication(boolean
      rangeIndication)`
    
- Presentation Reconciler
    
    Every time the user changes the document, the presentation reconciler determines which region of the visual presentation should be invalidated and how to repair it. Such a presentation reconciler can be defined via`org.eclipse.ui.genericeditor.presentationReconcilers`extension.
    
- PreferenceChangedListener
    
    PreferenceChangedListener can be used in PresentationReconciler to update the documents Presentation directly when settings are changed  (instead of having to reopen the editor, I think) → like example: use Themes extension point and colorRegistry() to update highlighting colors. 
    
- Rules
    
    Provides a framework for rule based text scanning and uses the framework to provide rule-driven default implementations of `IPresentationDamager`, `IPresentationRepairer` and `IDocumentPartitioner`.
    
    `RuleBasedScanner`is a document-based scanner controlled by `IRule`objects. When evaluated an `IRule`always returns an `IToken`. The package provides a set of rules whereby `PatternRule` is the most important one. `PatternRule`
     defines a pattern-configurable rule.
    
- getActiveEditor()
    
    ```java
    package com.vogella.ide.editor.tasks;
    
    import org.eclipse.ui.IEditorPart;
    import org.eclipse.ui.IWorkbench;
    import org.eclipse.ui.IWorkbenchPage;
    import org.eclipse.ui.IWorkbenchWindow;
    import org.eclipse.ui.PlatformUI;
    
    public class Util {
    
        private Util() {
            // only helper
        }
    
        public static IEditorPart getActiveEditor() {
            IWorkbench workbench = PlatformUI.getWorkbench();
            IWorkbenchWindow activeWorkbenchWindow = workbench.getActiveWorkbenchWindow();
            if (null == activeWorkbenchWindow) {
                activeWorkbenchWindow = workbench.getWorkbenchWindows()[0];
            }
            IWorkbenchPage activePage = activeWorkbenchWindow.getActivePage();
            if (activePage == null) {
                return null;
            }
            return activePage.getActiveEditor();
        }
    }
    ```
    
- org.eclipse.core.resources.**IResource**
    
    The workspace analog of file system files and directories. There are exactly four *types* of resource: files, folders, projects and the workspace root.
    
    File resources are similar to files in that they hold data directly. Folder resources are analogous to directories in that they hold other resources but cannot directly hold data. Project resources group files and folders into reusable clusters. The workspace root is the top level resource under which all others reside.
    
    Features of resources:
    
    - `IResource` objects are *handles* to state maintained by a workspace. That is, resource objects do not actually contain data themselves but rather represent resource state and give it behavior. Programmers are free to manipulate handles for resources that do not exist in a workspace but must keep in mind that some methods and operations require that an actual resource be available.
    - Resources have two different kinds of properties as detailed below. All properties are keyed by qualified names.
        - Session properties: Session properties live for the lifetime of one execution of the workspace. They are not stored on disk. They can carry arbitrary object values. Clients should be aware that these values are kept in memory at all times and, as such, the values should not be large.
        - Persistent properties: Persistent properties have string values which are stored on disk across platform sessions. The value of a persistent property is a string which should be short (i.e., under 2KB).
    - Resources are identified by type and by their *path*, which is similar to a file system path. The name of a resource is the last segment of its path. A resource's parent is located by removing the last segment (the resource's name) from the resource's full path.
    - Resources can be local or non-local. A non-local resource is one whose contents and properties have not been fetched from a repository.
    - *Phantom* resources represent incoming additions or outgoing deletions which have yet to be reconciled with a synchronization partner.
    
    Resources implement the `IAdaptable` interface; extensions are managed by the platform's adapter manager.
    
- **IContainer**
    
    Interface for resources which may contain other resources (termed its *members*). While the workspace itself is not considered a container in this sense, the workspace root resource is a container.
    
    Containers implement the `IAdaptable` interface; extensions are managed by the platform's adapter manager.
    
- IEditorInput
    
    `IEditorInput` is a light weight descriptor of editor input, like a file name but more abstract. It is not a model. It is a description of the model source for an `IEditorPart`.
    
    Clients implementing this editor input interface should override `Object.equals(Object)` to answer true for two inputs that are the same. The `IWorkbenchPage.openEditor` APIs are dependent on this to find an editor with the same input.
    
    Clients should extend this interface to declare new types of editor inputs.
    
    An editor input is passed to an editor via the `IEditorPart.init` method. Due to the wide range of valid editor inputs, it is not possible to define generic methods for getting and setting bytes.
    
    Editor input must implement the `IAdaptable` interface; extensions are managed by the platform's adapter manager.
    
- IEditorPart
    
    An editor is a visual component within a workbench page. It is typically used to edit or browse a document or input object. The input is identified using an `IEditorInput`. Modifications made in an editor part follow an open-save-close lifecycle model (in contrast to a view part, where modifications are saved to the workbench immediately).
    
    An editor is document or input-centric. Each editor has an input, and only one editor can exist for each editor input within a page. This policy has been designed to simplify part management.
    
    An editor should be used in place of a view whenever more than one instance of a document type can exist.
    
    This interface may be implemented directly. For convenience, a base implementation is defined in `EditorPart`.
    
    An editor part is added to the workbench in two stages:
    
    1. An editor extension is contributed to the workbench registry. This extension defines the extension id, extension class, and the file extensions which are supported by the editor.
    2. An editor part based upon the extension is created and added to the workbench when the user opens a file with one of the supported file extensions (or some other suitable form of editor input).
    
    All editor parts implement the `IAdaptable` interface; extensions are managed by the platform's adapter manager.
    

important Links: 

- FAQs: [https://wiki.eclipse.org/FAQ_Pages](https://wiki.eclipse.org/FAQ_Pages),
- Eclipse: [https://www.eclipse.org/articles](https://www.eclipse.org/articles/using-perspectives/PerspectiveArticle.html)
- Vogella:
    - [https://www.vogella.com/tutorials/EclipsePlugin/article.html](https://www.vogella.com/tutorials/EclipsePlugin/article.html)
    - [https://www.vogella.com/tutorials/EclipsePreferences/article.html](https://www.vogella.com/tutorials/EclipsePreferences/article.html)
    

more Links: 

[http://blog.eclipse-tips.com/2008/08/adding-color-and-font-preferences.html](http://blog.eclipse-tips.com/2008/08/adding-color-and-font-preferences.html)

- [https://rtist.hcldoc.com/help/index.jsp?topic=%2Forg.eclipse.platform.doc.isv%2Fguide%2Fruntime_registry.htm](https://rtist.hcldoc.com/help/index.jsp?topic=%2Forg.eclipse.platform.doc.isv%2Fguide%2Fruntime_registry.htm)
- [https://www.vogella.com/tutorials/EclipseExtensionPoint/article.html](https://www.vogella.com/tutorials/EclipseExtensionPoint/article.html)

- Editor Backup
    
    ```
    Montag: Java Model 
    Dienstag: FoldingStructureProvider 
    Donnerstag: PreferencePages 
    Freitag: PreferencePages, initialize Storage + Settings, access Settings
    Samstag: TextEditor vs TextViewer, Editor has projection Annotation model.
    Sonntag: DocumentProvider, docProvider.getAnnotationModel(), setDocument(EditorInput), TextViewer > SourceViewer > ProjectionViewer > JavaSourceViewer
    
    ————————————
    
    ——
    Understanding Code 2 - TextViewer Line Editing:
    -> From UI’s textEditor.getSourceViewer() 
    -> returns TextViewer / ProjectionViewer 
    -> 
    
    Good Morning! :
    -> where could I feed back an info line (generated from a ProjectionAnnotation’s associated Text) back into what is displayed by Editor or Text Viewer 
    	- editor or sourceViewer
    	- ask greg
    -> goal -> start by playing with simply replacing text for fun ! :)
    	-> likely, some interim representation in JavaEditor of text to be displayed (separate from Document) -> maybe insert line here. 
    
    - FoldingStructureProvider creates ProjectionRange with addProjectionRange()
     -> (Annotation, Position) is added to the ProjectionAnnotationModel of the Editor’s ProjectionViewer 
    -> Annotation -> ProjectionAnnotation -> JavaProjectionAnnotation
    -> Annotation has type and associated Text as String -> I guess folded Text
    -> meaning I can access the hidden Text when creating the ProjectionAnnotation 
    -> parse it to extract info to display   -> can I utilize something prebuilt here?
    -> hide the entire annotation block and replace (where?) with created info line. 
    	-> JavaModel structure for highlighting and linking will get lost -> will it? 
    
    Understanding Editor: 
    - DocumentProvider (passing text to be displayed and edited from actual document) 
    - AnnotationModel (from DocumentProvider.getAnnotationModel() — contains all AnnotationRanges) 
    - getDocumentProvider(DocumentProvider provider) -> method in AbstractTextEditor
    - setDocumentProvider(EditorInput input) -> method inAbstractDecoratedTextEditor - takes input  = file !!!
    - uses DocumentProviderRegistry.getDefault() DocProvider -> to pass input (as File from editorInput.getAdapter()). 
    to JavaEditor -- implements AbstractDecoratedTextEditor
    - DocumentProvider stores actual IDocument object (in ElementInfo Class inherited from AbstractDocumentProvider) -> creates this from IEditorInput (with method createDocument())
    - AbstractDecoratedTextEditor has implicit DocProvider + explicit DocProvider from setDocumentProvider() 
    - TextEditor (=standard Text Editor) -> extends AbstractDecoratedTextEditor
    - JavaEditor --> extends AbstractDecoratedTextEditor
    - JavaEditor -> can get SourceViewer (=ProjectionViewer) with AbstractDecoratedTextEditor method getSourceViewer()
    - note: documentProvider ExtensionPoint exists
    - So document provider hands over the actual master document? - if yes: where is projection document?
    - Class IEditorInput : 
    
    Subclasses: 
    TextViewer > SourceViewer > ProjectionViewer > JavaSourceViewer 
    doOperation() method with cases 
    
    - what are slaveDocuments vs master document
    
    - looked at formatElementAction() in JavaEditor -> selects Range in JavaSouceViewer viewer and initiates actual formatting = editing of the Document. 
    	-> close but not what I’m trying to do. 
    	-> because Editor (with DocumentProvider with IDocument) is focused on editing 
    	-> look at TextViewer classes next ! :)  - this is going good! :) 
    
    -> switch to partial projection range strategy. see how projections are created, if could be made for partial lines. 
    -> see how GitHub example did it. 
    
    -> FoldingStrucProvider.alignRegion() -> might be responsible for whole line Regions.
    -> is used for Region Array (comments, last ->code) for each element. in ComputeProjectionRanges. 
    - where was “only full line … are supported” mentioned ?  -> ProjectionViewer   !!!
    - why ? 
    - JavaEditor uses ProjectionViewer - not to be subclassed - solve how ? 
    -> continue here -> does it make sense to replace / subclass ProjectionViewer   +  why does it not support ? (maybe it will work, could just start trying? ) 
    - also uses JavaProjectionAnnotation (-> has “lineCount” … might not work with partial line approach)  ff
    
    Supporting Partial Line Projections: 
    - ProjectionViewer uses Package Private Methods (ProjectionSummary ) 
    - alignRegion(IRegion) returns Class Region describing Offset and Length with lineNumbers !!! 
    -> there are individual character level positions, but those get translated to line numbers in alignRegion() -> Region !!!
    -> createMember/CommentPosition() takes aligned Regions -> produces Positions . 
    -> adds ProjectionRange (new JavaProjectionAnnotation (type of JavaElement, collapsed), Position) 
    -> FoldingStructureComputationContext.addProjectionRange()  -> saves in HashMap 
    
    threads: 
    
    - ProjectionViewer’s add/removeMasterDocumentRange()  -> also normalizes to start of line. 
    
    - look at where code is relying on Regions referring to line numbers in the document. 
    - Positions (as Line Numbers) just get passed on -> where are they being used to display editor ? 
    -> ProjectionViewer.collapse() 
    -> ProjectonAnnotationModel() -> collapse(Annotation) -> markCollapsed and notifyListeners
    
    continue following position(lineNr) path -> + first try out changing to non-Normalized. 
    
    JavaEditor: 
    - creates SourceViewer to be used
    - creates ViewerPreferences Object
    - stores AnnotationModel 
    - creates/stores DocumentProvider (-> Document, AnnotationModel)
    - Runner to toggle Folding when editor is visible. 
    - formatElement -> edits Document
    - stores selectionProvider to be used with Editor
    
    TextViewer
    - TextEvent vs DocumentEvent
    - Input Document vs VisibleDocument -> The visible document represents the visible region of the viewer's input document.
    - A text viewer serves as text operation target
    - creates ProjectionEvents (according to IJavaFoldingStrcutureProvider install() ) 
    - has IDocuments inputDocument and visibleDocument
    - WidgetCommands -> Replace Commands TextViewerText Events auf Document übertragen. 
    - DocumentEnvent -> Specification of changes applied to documents. -> document range whose text gets replaced with different text. 
    - has registered TextListeners to be informed upon change specified by WidgedCommand
    - setTextColor()
    - StyledText fTextWidget -> 
    
    Qs:
    - visibleDocument listener in TextViewer ?
    updateslavedocument in TextViewer ? 
    
    - this will take some time to really wrap your head around -> which is great, because it will stretch your brain and skills so much and make you a much more competent 
    programmer before you start your professional life! 
    - so, just take it slow, be structured and methodical about where and how you apply your learning / understanding effort and utilize your resources. 
    - be ok with a long process because the point here is to multiply your skills. 
    - take time to bike and relax and enjoy the process!!
    
    plan: 
    - add case IJavaElement.Annotation to computeFoldingstructure.
    	- is comment / implementation strategy just assuming comments and code are alway made collapsable together
    
    present: 
    - questions? 
    - my plan - any adjustments? 
    - research I’ve done: 
    	- what should we talk about ? 
    	- my understanding of eclipse dev, modules (JavaModel) etc. - some questions about that.
    	- folding modifications -> OK
    	- integrating settings ->
    		 selecting folding provider in preferences
    		 preferences page - no boxes - but settings from default folding are reflected
    		- JavaPlugin Constructor (variable = this; why?)
    
    Thinking is writing: 
    - Extension Point ui.preferencePages exists and is easy to use. The existing FoldingPreferencePage does use the same extension point but I’m not sure replacing it through the point is a good idea (“is not API” when trying to implement the same classes object to be replaced implements, discouraged access, .internal. packages). -> downsides -> simple options are not visible (but work), + second page (maybe ok).
    -> ask about the difference of REPLACING an extension point contribution, vs. adding an optional foldingStructureProvider. 
    
    InfoLine Ideas: 
    I need to manipulate the displayed Text at some level (TextViewer or TextEditor)
    -> would be best to only be able to apply manipulation to the annotation’s ProjectionRange. 
    
    PreferencesIdeas: :
    -> probably better to just use separate preference page 
    -> use this tutorial to learn how to save settings from settings page 
    -> and access from code to use in foldingCode:
    7. Exercise: Contribute a preference page to the Eclipse IDE 
    -> fix initializePreferences() -> eval. just copy checkboxes into my preference page to have uniform preference representation there. 
    -> choose a good directory path for the annotation preferencePage.
    
    Evening: 
    -  normalize naming conventions
    	- workbenchprefPage -> init() -> pluginId
    - GitHub upload: 
    
    - what is jdt.ui.text.folding ? 
    - why FoldingstructureComputationContext has firstType() ?
    …	
    Forumulate Stackoverflow Question to old Brittish friend 
    
    Prep for progress report: 
    - url package name confirmation 
    - 
    
    Parts: 
    - Document Learning 
    - Tutorial on how to tackle plugin project
    - Testing 
    - Think of ways to utilize: properties, outline etc. for dialog part. 
    
    Steps: 
    - Vogella Tutorials 
    - Stackoverlow Research + asked question
    - Eclipse_4_tutorial.pdf 
    
    the Eclipse IDE itself is still based on the 3.x API, so if you extend it, you automatically need to use the compatibility layer. 
    Working Investigations:
    - difference between changing two code locations (case members in computeFoldingStructure vs. computeProjectionRanges add Tokens.Annotations) 
    - start trying these modifications. -> should let me achieve folding easily. 
    - what can be folded right now? -> methods and comments above + header comment. 
    	- replace line in document
    	- dialog for selecting options 
    
    get back into it: 
    - my goals: 
    	- annotation folding (super ez) 
    		- add annotations to Members case block
    		- try:  add Annotations to computeProjectionRanges() (where Regions[] Array with comments + last Implementing Source Reference is created).
    		- edit shown line above folded region. 
    	- preferences: 
    		-add my preferences
    		- display preferences when my foldingProvider is installed. 
    	- dialog for selecting relevant annotation arguments (finger exercise) 
    	- testing(contributing book) , wizard, help.
    		- writing 
    
    	•	write report
    	•	how to get into plugin development
    
    Preferences: 
    - preferences: where do preferences come from? 
    - AbstractUIPlugin -> getPreferenceStore. 
    - PreferenceConstants -> contains string names used to read settings in JDT-UI preference store. 
    - IPreferenceStore contains table mappings to values (=preferences) 
    - org.eclipse.jdt.ui.preferences -> FoldingPreferencesPage -> add to existing folding preference page. 
    
    String Editing in Editor: 
    -> work with projection Range ? 
    
    ————————
    
    comments can only be collapsed if above a member Test: 
    
    /*
     * yo you 
     *  
     *  */ 
    
     final class yoyo{
    	private yoyo() {}
    	int yo = 0;
    	/*
    	 * yo you 
    	 *  
    	 *  */ 
    	public void yoeas(){
    		
    	}
    }
    ```
    

Github Markdown: 

- eclipse plugin getting started guide.